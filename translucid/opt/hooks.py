# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01_hooks.ipynb.

# %% auto 0
__all__ = ['CancelFitException', 'Hook', 'HooksCtx', 'Hooks', 'NamedHooks']

# %% ../../nbs/01_hooks.ipynb 1
import torch
from torch import nn
from collections import OrderedDict


# %% ../../nbs/01_hooks.ipynb 6
class CancelFitException(Exception): pass


class Hook:
    def __init__(self, module: nn.Module, fn, when='forward'):
        attr = f'register_full_{when}_hook' if when == 'backward' else f'register_{when}_hook'
        self.hook = getattr(module, attr)(self._wrap_fn(fn))

    def remove(self): self.hook.remove()

    def _wrap_fn(self, fn):
        def _inner(*args, **kwargs):
            return fn(self, *args, **kwargs)
        return _inner

    def __del__(self): self.remove()


class HooksCtx:
    def __delitem__(self, i):
        self[i].remove()
        del super()[i]

    def remove(self): raise NotImplementedError
    def __del__(self): self.remove()
    def __enter__(self): return self

    def __exit__(self, exc_type, exc_value, _):
        self.remove()
        if exc_type == CancelFitException:
            print(f'Cancelled fit at {exc_value}')
            return True


class Hooks(list, HooksCtx):
    def __init__(self, *ms, fn, when='forward'): 
        super().__init__([Hook(m, fn, when) for m in ms])

    def remove(self):
        for h in self: h.remove()


class NamedHooks(OrderedDict, HooksCtx):
    def __init__(self, mdict: dict, fn, when='forward'):
        super().__init__({k: Hook(m, fn, when) for k, m in mdict})

    def remove(self):
        for h in self.values(): h.remove()
